import numpy as np
import numpy.typing as npt
from typing import Optional

def traverse(
    next_: npt.NDArray[np.uint64],
    start: int,
    num: int,
) -> npt.NDArray[np.uint64]: ...

def par_traverse(
    next_: npt.NDArray[np.uint64],
    starts: npt.NDArray[np.uint64],
    num: int,
) -> npt.NDArray[np.uint64]: ...

def gae(
    values: npt.NDArray[np.float32],
    rewards: npt.NDArray[np.float32],
    terminated: npt.NDArray[np.bool_],
    truncated: npt.NDArray[np.bool_],
    lambda_: float,
    discount: float,
    normalize_advantages: bool,
) -> tuple[npt.NDArray[np.float32], npt.NDArray[np.float32]]: ...

def par_gae(
    values: npt.NDArray[np.float32],
    rewards: npt.NDArray[np.float32],
    terminated: npt.NDArray[np.bool_],
    truncated: npt.NDArray[np.bool_],
    lambda_: float,
    discount: float,
    normalize_advantages: bool,
) -> tuple[npt.NDArray[np.float32], npt.NDArray[np.float32]]: ...

class Priorities:
    def __init__(self, len_: int) -> None: ...
    @staticmethod
    def build(array: npt.NDArray[np.float64]) -> Priorities: ...
    def sum(self) -> float: ...
    def max(self) -> float: ...
    def __len__(self) -> int: ...
    def __getitem__(self, i: int) -> float: ...
    def into_numpy(self) -> npt.NDArray[np.float64]: ...
    def update(self, i: int, x: float) -> None: ...
    def sample(self, x: float) -> tuple[int, Optional[float]]: ...
    def random_sample(self) -> tuple[int, float]: ...
    def multi_sample(self, x: npt.NDArray[np.float64]) -> tuple[npt.NDArray[np.uint64], npt.NDArray[np.float32]]: ...
    def random_multi_sample(self, num_samples: int) -> tuple[npt.NDArray[np.uint64], npt.NDArray[np.float32]]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

